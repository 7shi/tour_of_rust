- title: Глава 3 - Структуры данных
  content_markdown: >
    Время посмотреть на что-то помимо базовых типов! В этой главе мы посмотрим
    на самые примитивные структуры данных в Rust, уделив особое внимание их
    представлению в памяти. 

    Я думаю, вам понравится, что Rust так мало скрывает от вас то, как всё
    работает.
- title: Структуры
  content_markdown: >
    `struct` - это колекция полей.


    *field* (поле) - это просто какое-то значение, которое содержится в
    структуре. Значение поля может быть примитивным типом или другим типом,
    например структурой.


    Определение структуры - это как чертеж для компилятора, который указывает на
    то, как поля должны быть расположены в памяти.


    Поля в структуре расположены в памяти один за другим (компилятор может
    менять их местами для оптимизаций).
- title: Вызов метода
  content_markdown: >
    Методы - это функции, ассоциированные с определенным типом данных.


    **статические методы** - принадлежат к типу и вызываются с помощью оператора
    `::`.


    **методы объектов** — это методы, что можно применить только на уже
    созданном объекте через оператор `.`.


    Мы поговорим о том, как создавать свои методы в следующих главах.
- title: Память
  content_markdown: >
    Программы на Rust имеют 3 региона, в которых хранятся данные:


    * **data memory** (память данных) - для данных фиксированного размера и
    **статические** (доступны в любой момент
      времени выполнения программы). Рассмотрим текст в вашей программе (пример строка "Hello World!"). Эта строка - 
      это набор байт, которые нельзя изменить и можно только считать, поэтому они размещены в этом регионе. Компиляторы
      делают очень много оптимизаций с таким типом данных. Этот регион памяти считается очень быстрым, так как 
      местоположение данные известно и фиксировано заранее.
    * **stack memory** (стек) - для данных, что объявляются как переменные
    внутри блока видимости (например функция).
      Местоположение этого типа памяти никогда не меняется на протяжении вызова функции, из-за этого компиляторы
      могут оптимизировать код, поэтому стек очень быстро работает.
    * **heap memory** (куча) - для данных, которые создаются, пока приложение
    работает.
      Данные в этом регионе могут быть добавлены, перемещены, удалены, изменены в размере, и т.д. Из-за своей 
      динамической природы, считается что этот регион медленней остальных, но он позволяет более креативное использование
      памяти. Когда данные добавляются в этот регион, это называется **allocation** (выделение памяти). Когда данные 
      удаляются - deallocation (освобождение памяти).
- title: Создание структур
  content_markdown: >
    Когда мы **создаём экземпляр** структуры в коде, в памяти выделяется память
    для всех полей структуры.


    Создание екземпляра структуры выглядит так:


    `StructName { ... }`


    Мы указываем значения полей в фигурных скобках. Доступ к полям структуры
    происходит через оператор точку `.`.


    Подробности по примеру:

    * Текст внутри двойных кавычек - это данные только для чтения (пример
    "ferris"), следовательно 
      он размещается в *data memory* регионе
    * Вызов функции `String::from` создает структуру `String`, которая
    размещается рядом с другими полями 
      структуры SeaCreature в *стеке*. `String` (строка) представляет текст, который может быть
      изменен и делает это так:
      1. Выделяет память в *куче* (heap) для текста (размер выделенной памяти в куче может увеличиваться и уменьшаться)
      2. Берет ссылку на выделенную память с *кучи* и сохраняет ее в `String` (больше в следующих занятиях)
    * Наши два друга *Феррис* и *Сара* имеют структуры данных, которые всегда
    будут иметь фиксированные
      местоположения в нашей программе, так как они расположены на *стеке*.
- title: Кортежи-структуры
  content_markdown: >
    Для краткости, вы можете создавать структуры, которые используются точно так
    же как кортежи (tuple).
- title: Юнит-структуры
  content_markdown: >
    Структуры могут вовсе не иметь ни одного поля.


    Как было упомянуто в Главе 1, *юнит* - это то же самое, что и пустой кортеж
    `()`. Вот почему этот вид структур называют *юнит-структуры*.


    Этот тип не так распространен как остальные.
- title: Перечисления
  content_markdown: >
    Перечисления `enum` позволяют вам создавать новый тип, который имеет одно
    определенное значение из 

    списка перечисленных вами возможных значений.
- title: Перечисления с данными
  content_markdown: >
    Элементы `enum` также могут иметь один и больше типов данных (например,
    структуру или кортеж-структуру). 

    Это чем-то похоже на *union* в языке Си.


    Когда `enum` сравнивается с серией шаблонов (или матчится, англ. is pattern
    matched), вы можете

    связать имя переменной с каждым значением или полем структуры.


    Как `enum` представлен в памяти:

    * Перечисление будет иметь размер, равный наибольшему из его элементов. Это
    позволяет всем потенциальным
      значениям вместиться в одну и ту же область памяти (без дополнительных выделений памяти).
    * Элементы перечисления имеют невидимый числовой тэг в дополнении к данным,
    что этот элемент уже и так несет.


    Еще немного информации:

    * `enum` Rust(а) иногда называют *типом-сумой* (tagged-union)

    * Комбинирование разных типов, чтобы создать новый тип - это то, что люди
    имеют ввиду, когда говорят, что
      Rust имеет *алгебраические типы*
- title: Глава 3 - Заключение
  content_markdown: >
    Как здорово! Теперь у нас есть базовые инструменты для представления форм
    наших идей в коде. 

    Надеемся, что теперь мы можем увидеть проблеск того, как основные операции
    Rust работают в 

    гармонии и согласии с его типами. Далее мы поговорим о концепции, которая
    дает нашим типам данных 

    ещё большую гибкость представления: *дженерики* (шаблонные типы данных).
