- title: Глава 9 - Организация и структура проекта (Project Organization and Structure)
  content_markdown: >
    До этого момента все наши примеры кода находились в единственном файле.
    Давайте обсудим, как можно лучше оорганизовать и делиться кодом с другими!
- title: Модули (Modules)
  content_markdown: |
    Каждая Rust программа или библиотека является *crate* (крейтом).

    Каждый крейт (crate) сделан из иерархии *модулей* (modules), которые могут быть программами или библиотекой.

    Каждый крейт имеет корневой модуль (root module).

    Модуль содержит глобальные переменные, функции, структуры, типажи и даже другие модули!

    В Rust нет 1 к 1 отображения файлов на древовидную, иерархическую структуру модуля. Мы сами должны
    создать дерево модулей явным образом "в ручную" в вашем коде.
- title: Написание программы (Writing a Program)
  content_markdown: |
    Программа имеет корневой модуль в файле, с названием `main.rs`.
- title: Написание библиотеки (Writing a Library)
  content_markdown: |
    Библиотека имеет корневой модуль в файле, с названием `lib.rs`.
- title: Подключение других модулей и крейтов (Referencing Other Modules and Crates)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    На элементы из модуля можно ссылаться, подключая их в коде с помощью их полного, модульного пути
    `std::f64::consts::PI`.


    Использование ключевого слова **use** является Более простым способом.
    Он позволяет указать определенные элементы модуля, которые мы хотим использовать
    в коде без указания полного пути. Например `use std::f64::consts::PI`
    позволяет использовать короткий идентификатор `PI` в функции main.


    **std** является крейтом **standard library** (стандартной библиотеки) Rust, которая
    полна полезных структур данных для взаимодействия с вашей операционной системой.


    Каталог для поиска множества полезных крейтов, созданных сообществом, можно найти по адресу
    [https://crates.io](https://crates.io/).
- title: Подключение нескольких элементов (Referencing Multiple Items)
  content_markdown: |
    Можно подключить несколько элементов из одного модульного пути так:

    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    Феррис не кушает TAU, от кушает только PI.
- title: Создание модулей (Creating Modules)
  content_markdown: |
    Когда мы думаем о коде, мы обычно представляем себе иерархию файлов огранизованную
    в директориях. Rust позволяет создавать модули тесно связанную со структурой файлов.

    Есть два способа в Rust для объявления модуля. Например, модуль `foo` может быть
    представлен как:
      * файл с именем `foo.rs`
      * каталог с именем `foo` с файлом `mod.rs` внутри
- title: Иерархия модуля (Module Hierarchy)
  content_markdown: >
    Модуль может зависеть от другог модуля. Для установки отношений между модулем и
    его под-модулем, вы должны написать в родительском модуле:


    ```rust

    mod foo;

    ```


    Объявление выше будет искать файл с именем `foo.rs` или `foo/mod.rs`
    и вставит содержимое внутрь модуля с именем `foo` в текущей области видимости.
- title: Встроенный модуль (Inline Module)
  content_markdown: >
    Подмодуль может быть напрямую встроен внутри код модуля.


    Одно очень частое использование модулей это создание юнит тестов. Мы создаем
    встроенный можель, который существует только когда Rust используется для тестирования!


    ```

    // Данный макрос удаляет этот встроенный модуль, когда Rust
    // не в режиме тестирования.

    #[cfg(test)]

    mod tests {
        // Заметьте, что не можем сразу получить доступ к родительскому
        // модулю. Нужно указывать явно.
        use super::*;

        ... tests go here ...
    }

    ```
- title: Ссылка на встроенный модуль (Internal Module Referencing)
  content_markdown: >
    Rust имеет несколько ключевых слов, которые можно использовать для
    `use` (использования) пути в случае быстрого получения доступа к нужному
    модулю:

    * `crate` - корневой модуль вашего крейта

    * `super` - родительсвкий модуль вашего текущего модуля

    * `self` - текущий модуль
- title: Экспорт (Exporting)
  content_markdown: >
    По умолчанию элементы *module* (модуля) недоступны вне этого модуля
    (даже для их наследных модулей!). Элементы модуля можно сделать "видимыми" или
    доступными, используя ключевое слово `pub`.


    Также элементы *crate* (крейта) недоступны по умолчанию вне этого крейта. Их
    можно сделать доступными с помощью ключевого слова `pub` в *root module* (корневом модуле)
    крейта (`lib.rs` или `main.rs`).
- title: Область видимости структур (Structure Visibility)
  content_markdown: >
    Подобно функциям, структуры можно объявить так, что они будут видны снаружи своих
    модулей с помощью `pub`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: Автоимпорт (Prelude)
  content_markdown: |
    Вам может быть интересно, как мы получили доступ к типам `Vec` or `Box`
    везде в коде без использования `use` для их подключения.
    Это по причине использования модуля `prelude` (автоимпорт) из стандартной библиотеки.


    Know that in the Rust standard library anything that is exported in
    `std::prelude::*` is automatically available to every part of Rust.
    That is the case for `Vec` and `Box` but others as well (Option, Copy,
    etc.).
- title: Your Own Prelude
  content_markdown: >
    Because of standard library's prelude, it's common for your libary to have
    its own prelude module as a starting point for

    where users should import all of the most common data structures for using
    your library (e.g `use my_library::prelude::*`).

    It doesn't automatically get used in programs/libraries that use your crate,
    but it's a good convention to follow so people

    know where to start.


    Ferris says, "Be a good rustacean and help a fellow crab out with a good
    prelude!"
- title: Chapter 9 - Conclusion
  content_markdown: >
    You now have a few tricks up your sleeve when it comes to creating Rust
    applications and libraries ready for the world. Don't

    worry about remembering it all. As your library grows and is used by other
    people, you'll find what works best at each milestone.


    Resources:

    - [Guidelines For Writing Rust
    APIs](https://rust-lang.github.io/api-guidelines/)
