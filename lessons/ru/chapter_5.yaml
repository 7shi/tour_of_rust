- title: Глава 5 - Владение и Заимствование данными
  content_markdown: >
    Rust использует уникальную парадигму для управления памятью по сравнению с
    другими языками программирования. Мы посмотрим на поведение компилятора и то, как он
    проверяет код постепенно, иначе Вы рискуете быть ошеломлены. Важно понимать, что все эти
    правила существуют не для того, чтобы сделать Вашу жизнь сложнее, а для того, чтобы
    предотвратить широкий спектр ошибок.

- title: Владение
  content_markdown: >
    Создание объекта типа и **связывание** (binding) его с именем переменной
    создаёт ресурс в памяти, который будет валидироваться на протяжении всего своего
    **времени жизни**. Такую переменную называют **владельцем** ресурса.

- title: Управление ресурсами на основе области видимости
  content_markdown: >
    Rust использует последнее место использования или конец области видимости
    функции в качестве места, где делает свою работу деконструктор и деалоцируется ресурс.


    Термин для обозначения деконструктора и деалокации — **drop**. 


    Тонкости памяти:

    * В Rust нет сборщика мусора
    * Это может быть знакома Вам как идиома RAII (Resource Aquisition Is
    Initialization) из С++

- title: Drop по иерархии
  content_markdown: >
    Когда структура drop'ается, в начале происходит drop этой структуры, а потом
    её детей по очереди и так далее.  


    Тонкости памяти:

    * Автоматически очищая память, Rust помогает уменьшить количество утечек
    памяти

    * Ресурсы должны быть drop'нуты только один раз!

- title: Передача владения
  content_markdown: >
    Когда владелец ресурса используется в качестве аргумента функции, владение
    передаётся параметру этой функции. 


    После **передачи** (move) переменной, начиная с того места, где мы её
    передали, переменную больше нельзя использовать.


    Тонкости памяти:

    * **Передача** или **move** копирует память со стека владельца в стек
    параметров функции.

- title: Возвращение владения
  content_markdown: |
    Владение также может быть возвращено с функции.

- title: Заимствование у владельца с помощью ссылок
  content_markdown: |
    Ссылки позволяют нам заимствовать доступ к ресурсу с помощью оператора `&`.

    Ссылки drop'аются так же как и остальные ресурсы.

- title: Заимствование у владельца с правами на изменние
  content_markdown: >
    Мы также можем позаимствовать доступ к ресурсу с правами на его изменение с
    помощью оператора `&mut`.


    Владелец ресурса не может быть передан (move'нут) или изменён (права на
    изменения у `&mut` ссылки), пока он **mut**'абельно заимствован.


    Тонкости памяти:

    * Rust предотвращает изменение ресурса более чем с одного места, так как это
    может привести к гонкам данных (data race).

- title: Разыменование
  content_markdown: >
    Используя `&mut` ссылки, Вы можете установить значение переменной, используя
    `*` оператор.


    Вы также можете получить копию значения, используя `*` (только если значение
    может быть скопировано. Мы поговорим о копируемых типах в следующих главах).

- title: Передача заимствованных данных
  content_markdown: |
    Правила Rust'a для ссылок можно описать так:

    * В Rust можно иметь одну изменяемую ссылку на объект **или** несколько неизменяемых, но **не оба типа ссылок сразу**.
    * Ссылка не должна **жить дольше**, чем её владелец.

    Обычно нет проблем в передаче ссылок в функции.

    Тонкости:
    * Первое правило ссылок предотвращает гонки данных. Что такое гонки данных? Это когда чтение переменной
    одновременно происходит с записью в эту область памяти, из-за чего возможно Undefined Behaviour (UB).
    Такое часто происходит в мульти-поточных программах.
    * Второе правило ссылок предотвращает использование ссылок, что ссылаются на несуществующие данные
    ( висячие указатели, dangling pointers ).

- title: Ссылки на ссылки
  content_markdown: |
    Ссылки могут быть получены на поля объекта из ссылки на этот объект.

- title: Явное указание времени жизни
  content_markdown: |
    Даже если Rust не показывает/не указаны времена жизни в коде, компилятор знает время жизни
    каждой переменной и будет проверять, чтобы ссылка не существовала дольше своего владельца.

    Функции можно явно параметризовать в сигнатуре фунции символами, что помогут идентифицировать,
    какие параметры и возвращаемые значения имеют одинаковое время жизни.

    Имена времён жизни всегда начинаются с `'` (пример `'a`, `'b`, `'c`)

- title: Несколько времён жизни
  content_markdown: |
    Спецификация времени жизни позволяет разрешить ситуации, когда компилятор не знает, как соотносятся
    время жизни параметров и возвращаемого значения.

- title: Статические времена жизни
  content_markdown: |
    **Static** переменная - это область памяти, создаваемая во время компиляции, и которая существует 
    на протяжении всего времени выполнения программы. Такие переменные должны явно указывать свой тип.

    **Статическое время жизни** - это наибольшее возможное время жизни, то есть на протяжении всего 
    времени выполнения программы. Также можно создать переменную со **статическим временем жизни** и
    во время исполнения программы.

    Ресурсы со статическими временами жизни имеют спецификатор `'static`.

    `'static` никогда не вызовет **drop**.

    Если объкты со статическим временем жизни содержат ссылки, то они тоже должны быть `'static` ( любого другого 
    времени жизни не хватит )

    Тонкости памяти:

    * Изменение статических переменных — опасно, так как они глобально доступны всем для чтения, что может
      привести к гонкам данных. Мы поговорим про проблемы глобальных данных позже.
    * В Rust есть спецификатор `unsafe { ... }`, что позволяет пометить блок, в котором доступны некоторые операции,
      которые могут быть небезопасны ( так как компилятор не может их проверить ). Про 
      [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/)
      не стоит говорить абы как.

- title: Времена жизни в типах данных
  content_markdown: |
    Так же как и функции, типы данных могут быть параметризированы временами жизни своих полей. 

    Rust проверяет, чтобы структура, которая содержит ссылку, никогда не пережила объект, на который эта ссылка указывает. 

    У нас не будет структур, в которых ссылки указывают в никуда!

- title: Глава 5 - Заключение
  content_markdown: |
    Уф, Вы через многое прошли, поздравляю! Я знаю, тут было много информации, но Вы на пути
    становления Rustacean. Надеюсь, теперь понятней, как Rust пытается решить многие из 
    проблем системного программирования. 

    * Непреднамеренное измненение ресурсов
    * Забыть очистить память
    * Нечаянная очистка одной и той же памяти дважды ( double free ) 
    * Использование памяти после того, как она была удалена ( use after free )
    * Гонки данных, вызванные записью в область памяти, пока остальные считывают из этой области
    * Обозначение областей, где компилятор не дает нам гарантий безопасности

    В следующеей главе мы применим эти знания, когда будем смотреть, как Rust обрабатывает текстовые
    данные.
