- title: Глава 2 - Управление потоком исполнения
  content_markdown: >
    В этой главе мы поговорим про базовые методы управления потоком

    исполнения в Rust. Если вы знакомы с Си-подобными языками вы будете
    чувствовать

    себя как дома и может быть встретите пару сюрпризов.
- title: if/else if/else
  content_markdown: >
    Ветвление кода в Rust не особо отличается от того, к чему вы привыкли.


    Условия не оборачиваются в круглые скобки! Разве они нам действительно
    нужны? Теперь условные

    конструкции выглядят красиво и чисто.


    Все логические операторы, к которым вы так привыкли, всё еще работают: 

    `==`, `!=`, `<`, `>`, `<=`, `>=`, `!`, `||`, `&&`.
- title: loop
  content_markdown: |
    Нужен бесконечный цикл?

    В Rust есть такой.

    `break` прервёт цикл, когда вам будет нужно.

    `loop` имеет секрет, о котором мы вскоре поговорим.
- title: while
  content_markdown: |
    `while` это тот же `loop`, только с условием.

    Если условие будет `false`, цикл закончится.
- title: for
  content_markdown: >
    Rust(овый) цикл `for`, очень мощное средство.

    Он перебирает значения из любого выражения, которое вычисляется в итератор.
    А

    что такое итератор? Итератор - это обьект, которому вы можете сказать "Дай
    мне

    свой следующий элемент!" и так до тех пор, пока в нём не останется
    элементов.


    Мы посмотрим на это в следующей главе, между прочим Rust позволяет очень
    легко перебирать

    последовательности целых чисел.


    Оператор `..` создает структуру, которая итерируется с первого числа
    включительно по второе, в математике

    это называют полуинтервалом [0..5).


    Оператор `..=` делает то же самое, но итерируется по замкнутому интервалу
    [0..5]. Разница между

    ними в том что в первом случае не проитерируем пятёрку, а втором да.
- title: match
  content_markdown: >
    Хм, а где же оператор switch? Rust имеет очень полезный оператор

    `match` - он позволяет сравнивать значение с серией шаблонов

    и затем выполнять код в зависимости от того, какое значение совпало. Давайте
    посмотрим,

    как это работает с числами. Я расскажу больше в будущих главах, когда мы
    будем

    **match**(ить) более комплексные данные, и я обещаю, что вы не зря будете
    ждать.


    `match` требует обработки всех возможных случаев.


    Match(ить), используя деструктуризацию, один из самых распространенных
    паттернов в Rust.
- title: Возвращение значений из loop
  content_markdown: |
    Прерывая `loop`, вы можете возвратить значение.
- title: Возвращение значений из выражений-блоков
  content_markdown: >
    `if`, `match`, функции и блоки(scope blocks) - все имеют уникальный

    способ возвращать значение.


    Если последняя инструкция в `if`, `match`, функции или 

    блоке(scope block) не завершается `;`, Rust вернёт это значение 

    из данного блока. Это отличный способ создать краткую логику, которая

    возвращает какое-то значение, не создавая новую функцию, и сразу же
    присваивая

    это значение переменной.


    Примечание: если `if` имеет ветку `else`, его можно использовать как 

    тернарый оператор.
- title: Глава 2. Заключение
  content_markdown: >
    Надеюсь, я продемонстрировал силу Rust даже в самых основных возможностях

    языка. Мы будем говорить про `for` и `match` еще глубже, когда обретём
    больше

    знаний, которые позволят применить больше возможностей языка. В следующий
    раз

    мы перейдем к основополагающим структурам данных Rust.
