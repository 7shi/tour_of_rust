- title: Глава 1 - Основы
  content_markdown: |
    В первой главе мы узнаем об основах функций, переменных и примитивных
    типов. Рад видеть вас на борту!

    И ещё! Если вам интересно, кто этот восхитительный говорящий с вами краб,
    Я - **Феррис** - неофициальный маскот языка Rust. 
    Приятно познакомиться!
- title: The Rust Playground
  content_markdown: >
    В туре используется интерактивный компилятор
    [Rust](https://play.rust-lang.org/)


    Это хороший способ попробовать язык, показать креативность и ваши решения
    проблем!
- title: Переменные
  content_markdown: >
    Переменные объявляются с помощью ключевого слова **let**.


    Когда переменной присваивается значение, Rust может вывести её тип в 99%
    случаях.

    Когда вывод невозможен, вы можете добавить тип в объявление переменной.


    Заметьте, что мы можем присвоить значение одной и той же переменной
    несколько раз. Это называется

    сокрытие переменной (variable shadowing), её тип может быть изменен в
    последующих

    присваиваниях.


    Правильное применение регистра в именах переменных: `snake_case`
- title: Изменение переменных
  content_markdown: >
    Rust уделяет много внимания тому, какие значения могут быть изменены.

    Значения (переменные - области памяти) бывают двух типов:


    * **mutable** - перезаписываемые и считываемые

    * **immutable** - только считываемые


    Mutable значения всегда каким-то образом обозначены с помощью ключевого
    слова **mut**.


    Мы поговорим об этом позже, сейчас просто следите за этим ключевым словом и
    тем, какие элементы

    могут быть изменены.
- title: Базовые типы
  content_markdown: >
    В Rust много знакомых типов: 


    * булевые - `bool` представляет true/false

    * беззнаковые целочисленные - `u8`, `u32`, `u64`, `u128` представляют
    положительные числа

    * знаковые целочисленные - `i8`, `i32`, `i64`, `i128` представляют
    положительные/отрицательные числа 

    * целочисленные размером указателя - `usize`, `isize` представляют индексы и
    размеры

    * числа с плавающей точкой - `f32`, `f64`

    * текстовые - `str`, `char`

    * кортежи - `(значение,значение,...)` представляют фиксированную
    последовательность

    значений, размещаются на стеке

    * слайсы (slices) - `&[T]` представляют указатель на последовательность
    значений в памяти


    Мы поговорим о нескольких из них в деталях чуть позже.


    Справедливое предупреждение: на других языках текст может быть сложнее, чем
    вы привыкли.

    Rust - язык системного программирования, ориентированный на решение проблем
    памяти, 

    с которыми вы, возможно, не сталкивались. Мы поговорим о текстовых данных
    позже.
     
    Заметьте, что числа могут быть приведены к определенному типу, если явно
    указать 

    тип в конце числа (пример: `13u32`)
- title: Преобразование базовых типов
  content_markdown: >
    Rust требует ясности при работе с числами. Нельзя написать

    `u8`, работая с `u32`: это ошибка.


    К счастью, в Rust есть ключевое слово **as**, позволяющее очень легко
    преобразовывать

    типы.
- title: Константы
  content_markdown: >
    Константы (**const**) позволяют нам указать неизменяемое значение,

    которое можно использовать много раз. Вместо того, чтобы копировать
    значение,

    как у переменных, имя константы заменяется значением во время компиляции.


    В отличии от переменных, константам нужно явно обозначать их тип.


    Имена констант всегда пишутся в верхнем регистре `SCREAMING_SNAKE_CASE`
- title: Массивы
  content_markdown: >
    *Массив* - это коллекция с фиксированным количеством элементов одного
    типа.  


    Чтобы создать *массив*, напишите `[T; N]`, где T - тип элементов и N -
    количество элементов в массиве,

    заранее известное перед компиляцией. 


    Получить доступ к элементам массива можно с помощью `[x]`, где **x** индекс
    типа **usize** (начинается с 0).
- title: Функции
  content_markdown: |
    Функция может принимать ноль или больше аргументов.

    В этом примере функция **add** принимает два аргумента типа `i32`
    (целочисленное длиной 32 бита).

    Имена функций всегда пишутся в `snake_case`.
- title: Возврат нескольких значений
  content_markdown: >
    Функции могут возвращать несколько значений с помощью **кортежа** (tuple)

    значений.


    Доступ к значениям осуществляется по их позиции в кортеже.


    Rust поддерживает разные виды деструктуризации, которые вы увидите в разных
    формах.

    Это позволяет извлекать частички структур данных удобным способом. Смотрите

    внимательно!
- title: Возврат пустого значения
  content_markdown: >
    Если в функции не указан возвращаемый тип, она возвратит пустой кортеж,
    известный как **юнит**


    Пустой кортеж представлен `()`


    `()` для кортежа необычно, но вы будете часто замечать скобки и привыкните к
    ним.
- title: Раздел 1 - Заключение
  content_markdown: >
    Хорошая работа! Основы Rust не так уж и плохи, правда?  Мы получили

    представление о том, как думает компилятор языка. Ему очень важно знать
    размер

    значений в памяти, знать, могут ли значения изменятся, и Rust делает всё
    необходимое,

    чтобы математические операции вели себя так, как вы предполагаете. Это
    маленькое

    превью принципов **безопасности**(safety), распространённых в Rust.

    Компилятор всего лишь хочет, чтобы ваш код делал то, чего вы ожидаете! Далее
    мы

    рассмотрим конструкцию `if` и цикл `for`.
