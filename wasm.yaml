---
common_words:
  en:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  en_c:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  fr:
    chapter: Chapitre
    tor: Tour de WebAssembly
    next: Suivant
    previous: Précédant
    toc: Table des Matières
    lessons: Lessons
    untranslated: Untranslated
  fr_c:
    chapter: Chapitre
    tor: Tour de WebAssembly
    next: Suivant
    previous: Précédant
    toc: Table des Matières
    lessons: Lessons
    untranslated: Untranslated
  de:
    tor: Tour zu WebAssembly
    next: Weiter
    previous: Zurück
    toc: Inhaltsverzeichnis
    lessons: Kapitel
    chapter: Kapitel
    untranslated: Untranslated
  ie:
    tor: Tur de Rust
    next: Sequent
    previous: Precedent
    toc: Tabelle de contenete
    lessons: Lectiones
    chapter: Capitul
    untranslated: Untranslated
  ru:
    chapter: Глава
    tor: Тур по WebAssembly
    next: Далее
    previous: Назад
    toc: Содержание
    lessons: Занятия
    untranslated: Untranslated
  es:
    chapter: Capítulo
    tor: Tour de WebAssembly
    next: Siguiente
    previous: Anterior
    toc: Tabla de Contenidos
    lessons: Unidades
    untranslated: Untranslated
  pt-br:
    chapter: Capítulo
    tor: Um tour por WebAssembly
    next: Próximo
    previous: Anterior
    toc: Índice
    lessons: Unidades
    untranslated: Untranslated
pages:
  - en:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how Rust can be used to power the web.  If you are completely new to Rust, you might 
        appreciate the [Tour of Rust](https://tourofrust.com/)! Most of our examples will be easy
        enough to follow along by anyone though. This tour is also available in C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>
    en_c:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how C can be used to power the web. This tour is also available in Rust.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>

    fr:
      title: Salut, WebAssembly
      content_markdown: |
        Bienvenue au * Tour de WebAssembly *. Celui-ci a pour but d'être une introduction à la technologie
        et comment Rust peut être utilisé pour alimenter le Web. Si tu n'es pas à l'aise avec Rust,
        je te conseille le [Tour de Rust] (https://tourofrust.com/)! La plupart de nos exemples seront
        suffisamment simple pour pouvoir être suivie par n'importe qui, même les débutants.
        Cette visite est également disponible en C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu as des suggestions sur le contenu ou souhaite contribuer aux traductions,
        consultez le [dépôt github] du Tour de WebAssembly (https://github.com/richardanaya/tour_of_rust).

        Tu peux parcourir la visite avec le clavier <span class="emoji">⬅️</span> et <span class="emoji">➡️</span>
    fr_c:
      title: Salut, WebAssembly
      content_markdown: |
        Bienvenue au * Tour de WebAssembly *. Celui-ci a pour but d'être une introduction à la technologie
        et comment Rust peut être utilisé pour alimenter le Web. Cette visite est également disponible en Rust.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu as des suggestions sur le contenu ou souhaite contribuer aux traductions,
        consultez le [dépôt github] du Tour de WebAssembly (https://github.com/richardanaya/tour_of_rust).

        Tu peux parcourir la visite avec le clavier <span class="emoji">⬅️</span> et <span class="emoji">➡️</span>
    ie:
      title: Salute, WebAssembly
      content_markdown: |
        Benevenit al *Tur de WebAssembly*, un tur quel intente esser un introduction al tecnologie
        e qualmen on posse usar Rust por dar plu fortie al web. Si tu es un novon a Rust, noi recomanda li
        [Tour of Rust](https://tourofrust.com/)! Malgré to, li pluparte de nor exemples va esser facil
        a sequer por quicunc. Li tur es anc disponibil in C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu have suggestiones pri contenete o vole contribuer al traductiones,
        ples vider li [repositoria github](https://github.com/richardanaya/tour_of_rust) del Tur.

        Tu posse navigar tra li tur con li claves <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>

    pt-br:
      title: Olá, WebAssembly
      content_markdown: |
        Bem-vindo ao *Tour por WebAssembly*. Pretendemos ser uma introdução a esta tecnologia e de
        como o Rust pode ser usado para dar mais força à web. Se você é completamente novo no Rust pode
        apreciar o [Tour por Rust](https://tourofrust.com/)! A maioria dos nossos exemplos será fácil
        o suficiente para qualquer pessoa acompanhar. Este tour também está disponível para a
        linguagem C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Caso tenha alguma sugestão a respeito do conteúdo ou queira contribuir com as
        traduções, veja o repositório do Tour do WebAssembly [github repository](https://github.com/richardanaya/tour_of_rust).

        Você pode navegar pelo tour usando <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>
  - chapter: 1
    en:
      title: Chapter 1 - What Is WebAssembly?
      content_markdown: |
        WebAssembly is a binary format for representating isolated executable code.  It was developed for web
        browsers as an alternative to JavaScript with some distinct advantages:

        * Because its a low level bytecode, it's able to perform math quickly and manage memory more concisely.
        * WebAssembly was built with existing compilers in mind, allowing native languages like C/C++ and Rust to compile to it as a target.
        * Built with isolation in mind, allowing fine grain access control.
        * WebAssembly was built rather host agnostic, allowing some people to use WebAssembly [outside of browsers](https://wasmer.io/) too!

        WebAssembly is often called **WASM**
    en_c:
      clone: en
      
    fr:
      title: Chapter 1 - Qu'est-ce que WebAssembly?
      content_markdown: |
        WebAssembly est un format binaire pour représenter un code exécutable dans
        un environement isolé. Il a été développé pour être exécuté par les navigateurs
        web et propose une alternative au langage Javascript avec plusieurs avantages
        distincts:

        * Etant du bytecode de bas niveau, cela permet d'effectuer des calculs
        plus rapidement que le JavaScript et d'avoir plus de contrôle sur la gestion
        de la mémoire.
        * WebAssembly a été créé en s'inspirant des compilateurs existants, permettant
        ainsi aux langages natifs comme C / C ++ et Rust de produire ce bytecode.
        * Le bytecode étant exécuté dans un environement isolé, cela permet de
        contrôler son exécution.
        * WebAssembly a été construit indépendamment de l'hôte, rendant possible
        son utilisation [en dehors des navigateurs](https://wasmer.io/)!
 
        WebAssembly est souvent racourcie en ** WASM **.
    fr_c:
      clone: fr
      
    ie:
      title: Chapter 1 - Quo es WebAssembly?
      content_markdown: |
        WebAssembly es un formate binari por representar code executabil isolat. On developat it por navigatores web
        quam un alternative a JavaScript con quelc avantages distint:

        * Essente bytecode de bass nivelle, it posse far matematica rapidmen e gerer memorie con plu concisitá.
        * On constructet WebAssembly pensante pri compilatores existent, por que lingues nativ quam C/C++ e Rust mey compilar con it quam cible.
        * It esset constructet sur li principie de isolation, possibilisante control de accesse rafinat.
        * On constructet WebAssembly sin egard al hósped, con quel alcunes posse usar it anc [éxter navigatores web](https://wasmer.io/)!

        On nomina WebAssembly sovente **WASM**
    pt-br:
      title: Capítulo 1 - O Que É WebAssembly?
      content_markdown: |
        O WebAssembly é um formato binário para representar um código executável isolado. Foi
        projetado para ser executado nos navegadores de internet como uma alternativa ao 
        JavaScript com algumas vantagens nítidas:

        * Por ser um bytecode de baixo nível, é capaz de executar cálculos rapidamente e gerenciar
          a memória de forma mais concisa.
        * O WebAssembly foi projetado tendo os compiladores existentes em mente, permitindo que seja 
          compilado a partir de linguagens nativas como C/C++ e Rust.
        * Projetado com o isolamento em mente, permitindo um controle de acesso detalhado.
        * O WebAssembly foi projetado para ser bem agnóstico, permitindo que as pessoas usem o web 
          assembly [fora dos navegadores](https://wasmer.io/) também!

        O WebAssembly é frequentemente chamado de **WASM**.
  - en:
      title: Inside A Module
      content_markdown: |
        When you compile to a WebAssembly target your compiler should create a file ending in `.wasm` called a **module**.

        The module is a [binary format](https://webassembly.github.io/spec/core/index.html) full of information on how a 
        wasm program and its memory should be setup and interacted with:
        * a list of functions
        * what functions should be exported/imported
        * what data should initially be in the wasm modules memory
    en_c:
      clone: en
    fr:
      title: A l'Intérieur d'un Module
      content_markdown: |
        Lorsque tu compile vers du bytecode WebAssembly, le compilateur
        créer un fichier `.wasm` qu'on appele un **module**.

        Un module est un [format binaire](https://webassembly.github.io/spec/core/index.html)
        contenant des informations sur le programme wasm et sur la mémoire qu'il
        utilise. Un module contient:
        * une liste de fonctions
        * quelles fonctions doivent être exportées/importées
        * quelles données doivent se trouvées initialement dans la mémoire des modules wasm
    fr_c:
      clone: fr
    ie:
      title: Quo Sta in un Modul
      content_markdown: |
        Quande on compila a un cible de WebAssembly, li compilator deve crear un archive quel fini se con `.wasm` nominat un **modul**.

        Li modul es in [formate binari](https://webassembly.github.io/spec/core/index.html) e plen de information pri qualmen
        on mey crear e interacter con un programma wasm program e su memorie:
        * un liste de functiones
        * quel functiones mey esser exportat/importat
        * quel data mey esser in prim in li memorie del modules wasm
    pt-br:
      title: Por Dentro de um Módulo
      content_markdown: |
        Quando você compila para WebAssembly, seu compilador deve criar um arquivo terminado em 
        `.wasm` chamado de **módulo**.

        O módulo é um [formato binário](https://webassembly.github.io/spec/core/index.html) com 
        todas as informações para que um programa wasm e a sua memória sejam configurados 
        e interajam com:
        * uma lista de funções.
        * quais funções devem ser exportadas/importadas.
        * quais dados devem inicialmente estar na memória dos módulos wasm.
  - en:
      title: Loading A Module
      content_markdown: |
        Since a WebAssembly module is just a file of bytes. We first need to load those bytes in our browser.

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    en_c:
      clone: en
    fr:
      title: Charger un Module
      content_markdown: |
        Puisqu'un module WebAssembly n'est qu'un fichier d'octets,
        nous devons d'abord charger ces octets dans notre navigateur.

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    fr_c:
      clone: fr
    ie:
      title: Cargar un Modul
      content_markdown: |
        Nam un modul WebAssembly es solmen un archive de bytes, noi va in prim cargar ti-ci bytes in nor navigator

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    pt-br:
      title: Carregando um Módulo
      content_markdown: |
        Como um módulo de WebAssembly é apenas um arquivo de bytes, precisamos primeiro carregar esses
        bytes em nosso navegador.

        ```
        let file = await fetch('meu_arquivo.wasm');
        let bytes = await file.arrayBuffer();
        ```
  - en:
      title: Creating a Module
      content_markdown: |
        Modules are created from bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        During this phase we can **import** JavaScript functions we want our module to have access to. 
        We'll show an example of this next chapter.
    en_c:
      clone: en
    fr:
      title: Créer d'un Module
      content_markdown: |
        Les modules sont crées à partir des bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Au cours de cette phase, nous pouvons également définir les fonctions à
        **importer** et qui seront utilisées par notre module. Ne t'inquiète pas
        si ce n'est pas clair, nous verrons un exemple d'import de fonction par
        la suite.
    fr_c:
      clone: fr
    ie:
      title: Crear un Modul
      content_markdown: |
        Modules es creat de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durant ti-ci fase noi posse **importar** li functiones de JavaScript a quel noi vole que nor modul mey posser accesser. 
        Noi va dar un exemple de to in li capitul a sequer.
    pt-br:
      title: Criando um Módulo
      content_markdown: |
        Módulos são criados a partir de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durante esta fase podemos **importar** funções JavaScript que desejamos que nosso módulo
        tenha acesso. Mostraremos um exemplo no próximo capítulo.
  - en:
      title: Using a Module
      content_markdown: |
        A module will have one or more **export** functions that are accessible to JavaScript. Typically
        there is some export function to call in order to start a wasm program (e.g. `main`, `start`).

        ```
        module.instance.main();
        ```
    en_c:
      clone: en
    fr:
      title: Utiliser un Module
      content_markdown: |
        Un module peut **exporter** une ou plusieurs fonctions qui
        seront utilisable par le code JavaScript. Typiquement
        il existe une fonction à appeler pour démarrer
        un programme wasm (par exemple `main`,` start`).

        ```
        module.instance.main();
        ```
    fr_c:
      clone: fr
    ie:
      title: Usar un Modul
      content_markdown: |
        Un modul va haver un o pluri functiones **export** queles es accessibil a JavaScript. Tipicmen
        hay alquel function de export a vocar por comensar un programma de wasm (p.ex. `main`, `start`).

        ```
        module.instance.main();
        ```
    pt-br:
      title: Usando um Módulo
      content_markdown: |
        Um módulo tem uma ou mais funções **exportadas** que estarão acessíveis ao JavaScript.
        Tipicamente há uma função exportada que será chamada para iniciar um programa wasm
        (por exemplo: `main`, `start`).

        ```
        module.instance.main();
        ```
  - en:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `#[no_mangle]` tells our compiler to keep our function name human readable.
    en_c:
      title: 1+1
      code: https://webassembly.studio/?embed&f=glwzquv2gh8
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `__attribute__((visibility("default")))` tells our compiler to keep our function name human readable to JavaScript.
    fr:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Nous en savons suffisamment pour écrire notre premier module WebAssembly:
        l'addition de deux nombre! Le résultat sera affiché dans l'html.

        `#[no_mangle]` est un attribut disant au compilateur de conserver
        le nom de la fonction pour qu'on puisse l'appeler depuis le JavaScript.
    fr_c:
      title: 1+1
      code: https://webassembly.studio/?embed&f=glwzquv2gh8
      content_markdown: |
        Nous en savons suffisamment pour écrire notre premier module WebAssembly:
        l'addition de deux nombre! Le résultat sera affiché dans l'html.

        `__attribute __ ((visibility ("default")))` est une directive disant au compilateur
        de conserver le nom de la fonction pour qu'on puisse l'appeler depuis le JavaScript.
    ie:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Lass nos combinar nor conossenties por crear un module de WebAssembly
        con un sol **export**-function nominat `add` por addir du ciffres, e plazzar li 
        resultates in HTML.

        Con `#[no_mangle]` noi instructe li compilator mantener li nómine de nor function leibil por entes homan.
    pt-br:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Vamos juntar nossos conhecimentos e criar um módulo WebAssembly com uma única função `add` **exportada** para somar dois números e colocar o resultado em HTML.

        `#[no_mangle]` diz ao nosso compilador para manter o nome da nossa função legível para seres humanos.

  - en:
      title: Chapter 1 Conclusion
      content_markdown: |
        I hope it's clear that WebAssembly is not that complex fundamentally! In our next chapter we will 
        start looking into the details of how JavaScript and WebAssembly can talk about the same data.
    en_c:
      clone: en
    fr:
      title: Chapitre 1 Conclusion
      content_markdown: |
        J'espère t'avoir convaincu que, fondamentalement, WebAssembly
        n'est pas si compliqué que ça! Dans notre prochain chapitre, nous allons
        commencez à examiner en détail comment JavaScript et WebAssembly peuvent
        échanger des données.
    fr_c:
      clone: fr
    pt-br:
      title: Capítulo 1 - Conclusão
      content_markdown: |
        Espero que fique claro que o WebAssembly não é tão complexo fundamentalmente! No próximo capítulo começaremos a examinar os detalhes de como o JavaScript e p WebAssembly podem falar dos mesmos dados.
  - chapter: 2
    en:
      title: Chapter 2 - Sharing Data Structures
      content_markdown: |
        JavaScript and your WebAssembly program have very different representations of data at the memory level.
        To make matters more complex, interacting with the host environment from WebAssembly is very limited.
        In this chapter we will explore the strategies used to move data back and forth.
    en_c:
      clone: en
    pt-br:
      title: Capítulo 2 - Compartilhando Estruturas de dados
      content_markdown: |
        JavaScript e seu WebAssembly têm representações de dados muito diferentes no nível da memória.
        Para tornar as coisas mais complexas, a interação com o ambiente host do WebAssembly é muito limitada.
        Neste capítulo exploraremos as estratégias usadas para o vai-e-vem dos dados.
  - en:
      title: Importing Functions
      code: https://webassembly.studio/?embed&f=pp20eedhka
      content_markdown: |
        WebAssembly modules can only call functions that have been explicitly imported.

        Rust uses `extern "C" { ... }` to list the function signatures of those imported functions.

        Notice that calling an imported function is considered `unsafe` in Rust because the compiler
        can make no gaurantees about what happens within it's implementation.
    en_c:
      title: Importing Functions
      code: https://webassembly.studio/?embed&f=bah3p4wjere
      content_markdown: |
        WebAssembly modules can only call functions that have been explicitly imported.

        C uses the `extern` keyword to define signatures of the imported functions.
    pt-br:
      title: Importando Funções
      code: https://webassembly.studio/?embed&f=pp20eedhka
      content_markdown: |
        Os módulos WebAssembly podem chamar apenas funçõesque foram importadas explicitamente.

        O Rust usa `extern "C" { ... }` para listar as assinaturas dessas funções importadas.

        Observe que chamar uma função importada é considerado `não seguro` no Rust porque o compilador não pode dar garantias sobre o que acontece dentro da sua implementação.
  - en:
      title: Limitations of Functions
      content_markdown: |
        Parameter and return types of functions are limited to:

        * i32/i64
        * f32/f64

        So in order to communicate between JavaScript and WebAssembly we will have to get clever with the meaning of numbers!

        Rust is fairly good at converting it's primitive types to WebAssembly's numerical equivalents.
    en_c:
      title: Limitations of Functions
      content_markdown: |
        Parameter and return types of functions are limited to:

        * int/long
        * float/double

        So in order to communicate between JavaScript and WebAssembly we will have to get clever with the meaning of numbers!

        C is fairly good at converting it's primitive types to WebAssembly's numerical equivalents.

    pt-br:
      title: Limitações das Funções
      content_markdown: |
        Os parâmetros e tipos retornados pelas funções são limitados a:

        * i32/i64
        * f32/f64

        Portanto, para se comunicar entre JavaScript e WebAssembly, teremos que ficar espertos com o significado dos números!

        Rust e C são bastante bons em converter seus tipos primitivos nos equivalentes numéricos do WebAssembly.
  - en:
      title: Exporting Memory
      content_markdown: |
        WebAssembly programs export their memory as a long array of bytes (up to 4GB!). 

        The host can interpret from these bytes the data structures created by the program's code.

        Arrays of bytes can also be written directly into a program's memory from the host.

        Writing/reading bytes to/from a WebAssembly programs memory is
        the primary means of input and output of non-primitive types.
    en_c:
      clone: en
    pt-br:
      title: Exportando Memória
      content_markdown: |
        Os programas WebAssembly exportam sua memória como uma longa matriz de bytes (até 4 GB!). 

        O host pode interpretar a partir desses bytes as estruturas de dados criadas pelo código do programa.

        Matrizes de bytes também podem ser gravadas diretamente na memória de um programa a partir do host e vice-versa.

        Ler e gravar bytes na memória de programas do WebAssembly é o principal meio de entrada e saída de tipos não primitivos.
  - en:
      title: ArrayBuffer
      content_markdown: |
        JavaScript represents a long array of bytes as an `ArrayBuffer`

        You can get a typed view of this buffer that is very efficient to
        interact with.

        ```JavaScript
        // create an array of 8 bytes
        let bytes = new ArrayBuffer(8);
        // view those 8 bytes as 8-bit unsigned integers
        let u8_bytes = new Uint8Array(bytes);
        // modify the array buffer
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1;  // 00000001
        // re-interpret the u8_bytes's array buffer as 
        // little endian 32-bit signed integers
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]); 
        ///272 or 00010000000000010000000000000000
        ```
    en_c:
      clone: en
    pt-br:
      title: ArrayBuffer
      content_markdown: |
        JavaScript representa uma longa matriz de bytes como um `ArrayBuffer`.

        Você pode obter uma visualização tipada desse buffer de uma maneira muito eficiente para interagir.

        ```JavaScript
        // cria uma matriz de 8 bytes
        let bytes = new ArrayBuffer(8);
        // exibe estes 8 bytes como inteiros sem sinal de 8-bit
        let u8_bytes = new Uint8Array(bytes);
        // modifica o buffer da matriz
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1;  // 00000001
        // reinterpreta o buffer da matriz de u8_bytes como
        // 32-bit little endian inteiros com sinal
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]); 
        ///272 or 00010000000000010000000000000000
        ```
  - en:
      title: UTF-8 Encoding/Decoding
      content_markdown: |
        JavaScript provides utility functions for writing/reading UTF-8 strings to/from
        bytes inside of `ArrayBuffer` objects.

        ```JavaScript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 72;  // H
        data[1] = 105; // i
        data[2] = 33;  // !
        let str_len = 3;
        const utf8dec = new TextDecoder("utf-8");
        // sub array takes start and end index
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Hi!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(3) [72, 105, 33]
        ```
    en_c:
      clone: en
    pt-br:
      title: UTF-8 Encoding/Decoding
      content_markdown: |
        O JavaScript fornece funções utilitárias para ler e escrever strings UTF-8 para bytes dentro de objetos `ArrayBuffer` e vice-versa.

        ```JavaScript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 79;  // O
        data[1] = 105; // i
        data[2] = 33;  // !
        let str_len = 3;
        const utf8dec = new TextDecoder("utf-8");
        // subarray() pega o primeiro e último índice
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Oi!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(3) [72, 105, 33]
        ```
  - en:
      title: Logging Text
      code: https://webassembly.studio/?embed&f=1gxcr004p3x
      content_markdown: |
        Let's explore a simple example of logging some text from a WebAssembly program.

        We must:
        1. Create some utf-8 compliant text in our program's memory
        2. Determine the length of our text's bytes
        3. Somehow send the starting byte start index and length in bytes of that text data to the host browser so it can call `console.log`.

        Here's an example of what that receiving JavaScript function would look like:

        ```JavaScript
        wasm_log(start,len) {
          // extract text from memory location and length
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          console.log(text);
        }
        ```
    en_c:
      clone: en
      code: https://webassembly.studio/?embed&f=vh15t7nok4p
    pt-br:
      title: Logando Texto
      code: https://webassembly.studio/?embed&f=1gxcr004p3x
      content_markdown: |
        Vamos explorar um exemplo simples de logar um texto de um programa WebAssembly.

        Nós devemos:
        1. Criar um texto compatível com utf-8 na memória do nosso programa.
        2. Determinar o comprimento em bytes do nosso texto.
        3. De alguma forma, enviar o índice do byte inicial e o comprimento em bytes desses dados do texto para o navegador host, e então chamar o `console.log`.

        Aqui está um exemplo de como seria essa função de recebimento em JavaScript:

        ```JavaScript
        wasm_log(start,len) {
          // extrai o texto de um lugar da memória e seu comprimento
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          console.log(text);
        }
        ```
  - en:
      title: Reading Text
      code: https://webassembly.studio/?embed&f=ubmxmavgf2
      content_markdown: |
        Let's explore the opposite idea. Imagine we want to give some text to a WebAssembly program.

        We must:
        1. Determine the length in bytes of the text we want to pass in.
        1. Allocate some space in our memory of that byte length.
        2. Copy bytes into our program's memory at the start of the space we allocated.
        3. Let the WebAssembly program know we have put some data in it's memory at a specific index and lenth in bytes. 

        Here's an example of what that initialization looks like:

        ```JavaScript
        // Turn "Ferris" into bytes
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Allocate enough space for the text
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Put the text in WebAssembly program's memory
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Run the program
        module.instance.exports.main(start,len);
        ```
    en_c:
      clone: en
      code: https://webassembly.studio/?embed&f=0wwbpbvt4kwk
    pt-br:
      title: Lendo Texto
      code: https://webassembly.studio/?embed&f=ubmxmavgf2
      content_markdown: |
        Vamos explorar a ideia oposta. Imagine que queremos passar um texto para um programa WebAssembly.

        Nós devemos:
        1. Determinar o comprimento em bytes do texto que queremos passar.
        1. Alocar algum espaço em nossa memória com esse comprimento em bytes.
        2. Copiar os bytes para a memória do nosso programa no início do espaço que alocamos.
        3. Informar o programa WebAssembly que colocamos alguns dados na memória em uma posição e com um comprimento específicos em bytes.

        Aqui está um exemplo de como é essa inicialização:

        ```JavaScript
        // Transforma "Ferris" em bytes
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Aloca espaço suficiente para o texto
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Coloca o texto na memória do programa WebAssembly
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Executa o programa
        module.instance.exports.main(start,len);
        ```
  - en:
      title: Discovering Representations
      content_markdown: |
        You might find it annoying to pass around the length along with the start index of text.

        Consider this an opportunity to reflect upon useful conventions of the past like *C strings*
        that declare the end of text is a 0 value character `\0`.

        Don't want to pass around a byte packed data structure? Consider passing around json.

        You are in control of your representations in memory and what they mean and if they
        are appropriate for your use cases!
    en_c:
      clone: en
    pt-br:
      title: Descobrindo Representações
      content_markdown: |
        Você pode achar irritante passar pelo comprimento junto com o índice inicial do texto.

        Considere isso uma oportunidade para refletir sobre as convenções úteis do passado, tais como as *C strings* que declaram que o final do texto é um caractere de valor `\0`.

        Não quer passar uma estrutura de dados formatada em bytes? Considere passar um json.

        Você está no controle de suas representações na memória, o que elas significam e se são apropriadas para seus casos de uso!
  - en:
      title: Chapter 2 Conclusion
      content_markdown: |
        Crossing the boundry between host and WebAssembly program is cumbersome, but with it can come great performance. 
        It's important to remind ourselves that WebAssembly is a low -level executable byte code with concerns about memory
        structures that are much fine-grained than JavaScript. Check out your programming language's
        library support for tools that help make this an easier task! For Rust, [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) is a popular option.

        In our next chapter we will talk about a technique for dynamically calling JavaScript functions and garbage collection!
    en_c:
      title: Chapter 2 Conclusion
      content_markdown: |
        Crossing the boundry between host and WebAssembly program is cumbersome, but with it can come great performance. 
        It's important to remind ourselves that WebAssembly is a low -level executable byte code with concerns about memory
        structures that are much fine-grained than JavaScript. Check out your programming language's
        library support for tools that help make this an easier task!

        In our next chapter we will talk about a technique for dynamically calling JavaScript functions and garbage collection!
    pt-br:
      title: Capítulo 2 - Conclusão
      content_markdown: |
        Atravessar a fronteira entre o host e o programa WebAssembly é complicado, mas com ele podemos ter um ótimo desempenho.
        É importante lembrar que o WebAssembly é um byte-code executável de baixo nível com preocupações a respeito de estruturas de memória que são muito mais refinadas que o JavaScript. Confira o suporte da biblioteca da sua linguagem de programação para ferramentas que ajudam a tornar essa tarefa mais fácil! Para o Rust, o [wasm-bindgen] (https://github.com/rustwasm/wasm-bindgen) é uma opção popular.

        No próximo capítulo falaremos sobre uma técnica para chamar dinamicamente funções JavaScript e garbage collection!
  - beta: true
    chapter: 3
    en:
      title: Chapter 3 - Dynamic Invocation
      content_markdown: |
        In this chapter we will talk about how we can create our own dynamic functions at runtime to call from WebAssembly.
  - beta: true
    en:
      title: Why Dynamic Invocation?
      content_markdown: |
        We saw in the first chapters that we could easily write our own JavaScript functions by hand in our `.js` files, so why
        dynamically create functions?

        * Most people come to WebAssembly to escape JavaScript. Dynamic creation of JavaScript functions allow us to use
          libraries in our native language that do the hard part of dynamically creating their bindings without everyone having
          to recreate the wheel.
        * Simplifies our setup and bootstrapping of our WebAssembly module to a bare minimum. We only need the ability to register 
          new functions and call those new functions instead of specifying a litany of hand written JavaScript functions.
        * It's difficult for JavaScript to know what dependencies your module needs, by allowing the WebAssembly program to create its own functions
          it creates only exactly what it needs.

  - beta: true
    en:
      title: Logging Revisited
      content_markdown: |
        In our first chapter we manually wrote our log functions to do logging with `console.log`.  Let's consider how we would do this dynamically.

        * We need some way to register a function at runtime.
        * We need some way to call that function.
        * We'll need some way for that dynamic function to have access to memory (e.g. for extracting utf-8 bytes.)
  
  - beta: true
    en:
      title: Registering Functions
      content_markdown: |
        In order to register a function we need two things:

        * we need to pass body of function we want to create in JavaScript as a string
        * we need to get back a handle so we can call that function later with parameters

        ```rust
        register_function(js:&str) -> usize
        ``` 

        Since WebAssembly can only pass back and forth numbers, and since all numbers in JavaScript are 64-bit floats, 
        what this will look like ultimately is an imported function:

        ```
        register_function(js_start:f64,js_len:f64) -> f64
        ```

  - beta: true
    en:
      title: Calling Functions
      content_markdown: |
        When we later want to call our dynamic function by handle, we'll need some sort of invocation function.

        Again, since WebAssembly can only pass back and forth numbers, and since all numbers in JavaScript are 64-bit floats, 
        what this will look like ultimately is an imported function:

        ```
        js_invoke_with_2_params(fn_handle:f64, a:f64, b:f64) -> f64
        ``` 

        Putting it all together we

        ```rust
        let log_handle = register_function("
          (param_a, param_b) => {
            // somehow call console_log  
          }");
        let msg = "hello world";
        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
            msg.len() as f64 );
        ```

        You'll notice there is a problem with our JavaScript function though. It has the start and end of our utf-8 but not memory!

  - beta: true
    en:
      title: Context Of Dynamic Invocation
      content_markdown: |
        When our dynamically invoked functions are called, the functions need to have access to the module's memory. We can place
        important resources on a context object so our function has all the available tools to do it's job.

        ```rust
        let log_handle = register_function("
          (context, msgStart, msgEnd) => {
            let msg = context.getUtf8FromMemory(msgStart,msgEnd);
            console.log(msg); 
          }")
        let msg = "hello world";
        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
          msg.len() as f64);
        ```
  - beta: true
    en:
      title: Returning References
      content_markdown: |
        We run into an issue with dynamic functions when we want to return a reference to an object. WebAssembly can only pass
        around numbers! To break past this challenge, we must establish a convention of using a numerical handle to represent
        a reference to our object in JavaScript.

        When our dynamically invoked functions are called, the functions need to have access to the module's memory. We can place
        important resources on a context object so our function has all the available tools to do it's job.

        ```rust
        let query_selector_handle = register_function("
          (context, selectorStart, selectorEnd) => {
            let selector = context.getUtf8FromMemory(
              selectorStart,selectorEnd);
            let domEl = document.querySelector(selector);
            let objHandle = context.storeObject(domEl);
            return objHandle;
          }")
        let selector = "#fancy-button";
        js_invoke_with_2_params(
            log_handle,selector.as_ptr() as f64, 
            selector.len() as f64 );
        ```
  - beta: true
    en:
      title: Allocators
      content_markdown: |
        As we can see to properly communicate objects, we need to have some kind of storage mechanism for objects:

        * `storeObject(object) -> f64` - Stores and object and returns a numerical handle.
        * `getObject(f64) -> object` - Get a reference to an object by it's numerical handle.
        * `releaseObject(f64) -> object` - Release a reference to an object from storage, allowing it's memory to be freed.

        The implementation of something like this is called an *allocator*. This is beyond the scope of this tutorial. We
        could imagine a very naive implementation of this which is essentially just an ever growing vector where 
        when an object is stored in the vector and it's index is returned as the handle.

        ```
        let storage = [];

        function storeObject(obj){
          let index = storage.length;
          storage.push(obj);
          return index;
        }

        function getObject(handle){
          return storage[handle];
        }

        function releaseObject(handle){
          return storage[handle] = null;
        }
        ```

        There are many issues for you to consider with your implementation.

  - beta: true
    en:
      title: Drawing To The Screen
      content_markdown: |
        Let's put it all together with a an example by drawing a red square to the screen. Let's think about the function's we'll need
        to register:

        ```rust
        let get_2d_context = register_function("
          (context, selectorStart, selectorEnd) => {
            let selector = context.getUtf8FromMemory(
              selectorStart,selectorEnd);
            let domEl = document.querySelector(selector);
            let ctx = domEl.getContext("2d");
            let objHandle = context.storeObject(ctx);
            return objHandle;
          }");
        let set_context_color = register_function("
          (context, ctxHandle, colorStart, colorEnd) => {
            let color = context.getUtf8FromMemory(
              colorStart,colorEnd);
            let ctx = context.getObject(ctxHandle);
            ctx.fillColor(color);
          }");
        let draw_rect = register_function("
          (context, ctxHandle, x, y, width, height) => {
            let ctx = context.getObject(ctxHandle);
            ctx.fillRect(x,y,width,height);
          }");
        ```
  - beta: true
    en:
      title: Chapter 3 - Dynamic Invocation
      content_markdown: |
        We now have the ability to invoke any kind of JavaScript! How cool is that? Using eval obviously is not that idea,
        WebAssembly is an evolving technology that will one day have better ways to access any aspect of the 
        browser. Until then we do our best! The next chapter is on asynchronous programming!

  - beta: true
    chapter: 4
    en:
      title: Chapter 4 - Asynchronous Programming
      content_markdown: |
        Promises, etc.

  - chapter: 5
    en:
      title: The End
      content_markdown: |
        That's all for now. Stay tuned for new content. I hope you enjoy the journey ahead!
    en_c:
      clone: en
    ie:
      title: Fine
      content_markdown: |
        To es omnicos por nu. Plu tard va venir nov contenete. Yo espera que tu va juir li viage a sequer!
    pt-br:
      title: Fim
      content_markdown: |
        Isso é tudo por enquanto. Fique ligado para novos conteúdos. Espero que
        se divirta nesta jornada!
    es:
      title: Fin
      content_markdown: |
        Esto es todo por ahora, pero aún quedan más capítulos, así que ¡muy atento! Esperamos que disfrutes del viaje.