---
common_words:
  en:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  en_c:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  de:
    tor: Tour zu WebAssembly
    next: Weiter
    previous: Zurück
    toc: Inhaltsverzeichnis
    lessons: Kapitel
    chapter: Kapitel
    untranslated: Untranslated
  ie:
    tor: Tur de Rust
    next: Sequent
    previous: Precedent
    toc: Tabelle de contenete
    lessons: Lectiones
    chapter: Capitul
    untranslated: Untranslated
  ru:
    chapter: Глава
    tor: Тур по WebAssembly
    next: Далее
    previous: Назад
    toc: Содержание
    lessons: Занятия
    untranslated: Untranslated
  es:
    chapter: Capítulo
    tor: Tour de WebAssembly
    next: Siguiente
    previous: Anterior
    toc: Tabla de Contenidos
    lessons: Unidades
    untranslated: Untranslated
  pt-br:
    chapter: Capítulo
    tor: Um tour por WebAssembly
    next: Próximo
    previous: Anterior
    toc: Índice
    lessons: Unidades
    untranslated: Untranslated
pages:
  - en:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how Rust can be used to power the web.  If you are completely new to Rust, you might 
        appreciate the [Tour of Rust](https://tourofrust.com/)! Most of our examples will be easy
        enough to follow along by anyone though. This tour is also available in C.

        * [Rust (English)](index.html)
        * [Rust (Interlingue)](index_ie.html)
        * [Rust (Português Brasileiro)](index_pt-br.html)
        * [C (English)](index_en_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>
    en_c:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how C can be used to power the web. This tour is also available in Rust.

        * [Rust (English)](index.html)
        * [Rust (Interlingue)](index_ie.html)
        * [Rust (Português Brasileiro)](index_pt-br.html)
        * [C (English)](index_en_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>

    ie:
      title: Salute, WebAssembly
      content_markdown: |
        Benevenit al *Tur de WebAssembly*, un tur quel intente esser un introduction al tecnologie
        e qualmen on posse usar Rust por dar plu fortie al web. Si tu es un novon a Rust, noi recomanda li
        [Tour of Rust](https://tourofrust.com/)! Malgré to, li pluparte de nor exemples va esser facil
        a sequer por quicunc. Li tur es anc disponibil in C.

        * [Rust (English)](index.html)
        * [Rust (Interlingue)](index_ie.html)
        * [Rust (Português Brasileiro)](index_pt-br.html)
        * [C (English)](index_en_c.html)

        Si tu have suggestiones pri contenete o vole contribuer al traductiones,
        ples vider li [repositoria github](https://github.com/richardanaya/tour_of_rust) del Tur.

        Tu posse navigar tra li tur con li claves <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>

    pt-br:
      title: Olá, WebAssembly
      content_markdown: |
        Bem-vindo ao *Tour por WebAssembly*. Pretendemos ser uma introdução a esta tecnologia e de
        como o Rust pode ser usado para dar mais força à web. Se você é completamente novo no Rust pode
        apreciar o [Tour por Rust](https://tourofrust.com/)! A maioria dos nossos exemplos será fácil
        o suficiente para qualquer pessoa acompanhar. Este tour também está disponível para a
        linguagem C.

        * [Rust (English)](index.html)
        * [Rust (Interlingue)](index_ie.html)
        * [Rust (Português Brasileiro)](index_pt-br.html)
        * [C (English)](index_en_c.html)

        Caso tenha alguma sugestão a respeito do conteúdo ou queira contribuir com as
        traduções, veja o repositório do Tour do WebAssembly [github repository](https://github.com/richardanaya/tour_of_rust).

        Você pode navegar pelo tour usando <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>
  - chapter: 1
    en:
      title: Chapter 1 - What Is WebAssembly?
      content_markdown: |
        WebAssembly is a binary format for representating isolated executable code.  It was developed for web
        browsers as an alternative to JavaScript with some distinct advantages:

        * Because its a low level bytecode, it's able to perform math quickly and manage memory more concisely.
        * WebAssembly was built with existing compilers in mind, allowing native languages like C/C++ and Rust to compile to it as a target.
        * Built with isolation in mind, allowing fine grain access control.
        * WebAssembly was built rather host agnostic, allowing some people to use WebAssembly [outside of browsers](https://wasmer.io/) too!

        WebAssembly is often called **WASM**
    en_c:
      clone: en

    ie:
      title: Chapter 1 - Quo es WebAssembly?
      content_markdown: |
        WebAssembly es un formate binari por representar code executabil isolat. On developat it por navigatores web
        quam un alternative a JavaScript con quelc avantages distint:

        * Essente bytecode de bass nivelle, it posse far matematica rapidmen e gerer memorie con plu concisitá.
        * On constructet WebAssembly pensante pri compilatores existent, por que lingues nativ quam C/C++ e Rust mey compilar con it quam cible.
        * It esset constructet sur li principie de isolation, possibilisante control de accesse rafinat.
        * On constructet WebAssembly sin egard al hósped, con quel alcunes posse usar it anc [éxter navigatores web](https://wasmer.io/)!

        On nomina WebAssembly sovente **WASM**
    pt-br:
      title: Capítulo 1 - O Que É WebAssembly?
      content_markdown: |
        O WebAssembly é um formato binário para representar um código executável isolado. Foi
        projetado para ser executado nos navegadores de internet como uma alternativa ao 
        JavaScript com algumas vantagens nítidas:

        * Por ser um bytecode de baixo nível, é capaz de executar cálculos rapidamente e gerenciar
          a memória de forma mais concisa.
        * O WebAssembly foi projetado tendo os compiladores existentes em mente, permitindo que seja 
          compilado a partir de linguagens nativas como C/C++ e Rust.
        * Projetado com o isolamento em mente, permitindo um controle de acesso detalhado.
        * O WebAssembly foi projetado para ser bem agnóstico, permitindo que as pessoas usem o web 
          assembly [fora dos navegadores](https://wasmer.io/) também!

        O WebAssembly é frequentemente chamado de **WASM**.
  - en:
      title: Inside A Module
      content_markdown: |
        When you compile to a WebAssembly target your compiler should create a file ending in `.wasm` called a **module**.

        The module is a [binary format](https://webassembly.github.io/spec/core/index.html) full of information on how a 
        wasm program and its memory should be setup and interacted with:
        * a list of functions
        * what functions should be exported/imported
        * what data should initially be in the wasm modules memory
    en_c:
      clone: en
    ie:
      title: Quo Sta in un Modul
      content_markdown: |
        Quande on compila a un cible de WebAssembly, li compilator deve crear un archive quel fini se con `.wasm` nominat un **modul**.

        Li modul es in [formate binari](https://webassembly.github.io/spec/core/index.html) e plen de information pri qualmen
        on mey crear e interacter con un programma wasm program e su memorie:
        * un liste de functiones
        * quel functiones mey esser exportat/importat
        * quel data mey esser in prim in li memorie del modules wasm
    pt-br:
      title: Por Dentro de um Módulo
      content_markdown: |
        Quando você compila para WebAssembly, seu compilador deve criar um arquivo terminado em 
        `.wasm` chamado de **módulo**.

        O módulo é um [formato binário](https://webassembly.github.io/spec/core/index.html) com 
        todas as informações para que um programa wasm e a sua memória sejam configurados 
        e interajam com:
        * uma lista de funções.
        * quais funções devem ser exportadas/importadas.
        * quais dados devem inicialmente estar na memória dos módulos wasm.
  - en:
      title: Loading A Module
      content_markdown: |
        Since a WebAssembly module is just a file of bytes. We first need to load those bytes in our browser.

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    en_c:
      clone: en
    ie:
      title: Cargar un Modul
      content_markdown: |
        Nam un modul WebAssembly es solmen un archive de bytes, noi va in prim cargar ti-ci bytes in nor navigator

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    pt-br:
      title: Carregando um Módulo
      content_markdown: |
        Como um módulo de WebAssembly é apenas um arquivo de bytes, precisamos primeiro carregar esses
        bytes em nosso navegador.

        ```
        let file = await fetch('meu_arquivo.wasm');
        let bytes = await file.arrayBuffer();
        ```
  - en:
      title: Creating a Module
      content_markdown: |
        Modules are created from bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        During this phase we can **import** javascript functions we want our module to have access to. 
        We'll show an example of this next chapter.
    en_c:
      clone: en
    ie:
      title: Crear un Modul
      content_markdown: |
        Modules es creat de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durant ti-ci fase noi posse **importar** li functiones de javascript a quel noi vole que nor modul mey posser accesser. 
        Noi va dar un exemple de to in li capitul a sequer.
    pt-br:
      title: Criando um Módulo
      content_markdown: |
        Módulos são criados a partir de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durante esta fase podemos **importar** funções javascript que desejamos que nosso módulo
        tenha acesso. Mostraremos um exemplo no próximo capítulo.
  - en:
      title: Using a Module
      content_markdown: |
        A module will have one or more **export** functions that are accessible to JavaScript. Typically
        there is some export function to call in order to start a wasm program (e.g. `main`, `start`).

        ```
        module.instance.main();
        ```
    en_c:
      clone: en
    ie:
      title: Usar un Modul
      content_markdown: |
        Un modul va haver un o pluri functiones **export** queles es accessibil a JavaScript. Tipicmen
        hay alquel function de export a vocar por comensar un programma de wasm (p.ex. `main`, `start`).

        ```
        module.instance.main();
        ```
    pt-br:
      title: Usando um Módulo
      content_markdown: |
        Um módulo tem uma ou mais funções **exportadas** que estarão acessíveis ao JavaScript.
        Tipicamente há uma função exportada que será chamada para iniciar um programa wasm
        (por exemplo: `main`, `start`).

        ```
        module.instance.main();
        ```
  - en:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `#[no_mangle]` tells our compiler to keep our function name human readable.
    en_c:
      title: 1+1
      code: https://webassembly.studio/?embed&f=glwzquv2gh8
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `__attribute__((visibility("default")))` tells our compiler to keep our function name human readable to JavaScript.
    ie:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Lass nos combinar nor conossenties por crear un module de WebAssembly
        con un sol **export**-function nominat `add` por addir du ciffres, e plazzar li 
        resultates in HTML.

        Con `#[no_mangle]` noi instructe li compilator mantener li nómine de nor function leibil por entes homan.
    pt-br:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Vamos juntar nossos conhecimentos e criar um módulo WebAssembly com uma única função `add` **exportada** para somar dois números e colocar o resultado em HTML.

        `#[no_mangle]` diz ao nosso compilador para manter o nome da nossa função legível para seres humanos.

  - en:
      title: Chapter 1 Conclusion
      content_markdown: |
        I hope it's clear that WebAssembly is not that complex fundamentally! In our next chapter we will 
        start looking into the details of how JavaScript and WebAssembly can talk about the same data.
  - beta: true
    chapter: 2
    en:
      title: Chapter 2 - Sharing Data Structures
      content_markdown: |
        JavaScript and your WebAssembly program have very different representations of data.
        To make matters more complex, interacting with the host environment from WebAssembly is very limited.
        In this chapter we will explore the strategies used to move data back and forth.
  - beta: true
    en:
      title: Importing Functions
      code: https://webassembly.studio/?embed&f=pp20eedhka
      content_markdown: |
        WebAssembly modules can only call functions that have been explicitly imported.

        Rust uses `extern "C" { ... }` to list the function signatures of those imported functions.

        Notice that calling an external function is considered `unsafe` in Rust because the compiler
        can make no gaurantees about what happens within it's implementation.
  - beta: true
    en:
      title: Limitations of Functions
      content_markdown: |
        Parameter and return types of functions are limited to:

        * i32/i64
        * f32/f64

        So in order to communicate between JavaScript and WebAssembly we will have to get clever with the meaning of numbers!

        Rust is fairly good at converting it's primitive types to WebAssembly's numerical equivalents.
  - beta: true
    en:
      title: Exporting Memory
      content_markdown: |
        WebAssembly programs export their memory as a long array of bytes (up to 4GB!). 

        The host can interpret from these bytes the data structures created by the program's code.

        Arrays of bytes can also be written directly into a program's memory from the host.

        Writing/reading bytes to/from a WebAssembly programs memory is
        the primary means of input and output of non-primitive types.
  - beta: true
    en:
      title: ArrayBuffer
      content_markdown: |
        JavaScript represents a long array of bytes as an `ArrayBuffer`

        You can get a typed view of this buffer that is very efficient to
        interact with.

        ```javascript
        // create an array of 8 bytes
        let bytes = new ArrayBuffer(8);
        // view those 8 bytes as 8-bit unsigned integers
        let u8_bytes = new Uint8Array(bytes);
        // modify the array buffer
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1;  // 00000001
        // re-interpret the u8_bytes's array buffer as 
        // little endian 32-bit signed integers
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]); 
        ///272 or 00010000000000010000000000000000
        ```
  - beta: true
    en:
      title: UTF-8 Encoding/Decoding
      content_markdown: |
        JavaScript provides some utility functions for writing/reading UTF-8 strings to/from
        bytes inside of `ArrayBuffer` objects.

        ```javascript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 72;  // H
        data[1] = 105; // i
        data[2] = 33;  // !
        let str_len = 3;
        const utf8dec = new TextDecoder("utf-8");
        // sub array takes start and end index
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Hi!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(3) [72, 105, 33]
        ```
  - beta: true
    en:
      title: Logging Text
      code: https://webassembly.studio/?embed&f=1gxcr004p3x
      content_markdown: |
        Let's explore a simple example of logging some text from a WebAssembly program.

        We must:
        1. Create some utf-8 compliant text in our program's memory
        2. Determine the length of our text's bytes
        3. Somehow send the starting byte index and length in bytes of that text data to the host browser so it can call `console.log`.

        ```javascript
        wasm_log(start,len) {
          // extract text from memory location and length
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          ...
        }
        ```

  - beta: true
    en:
      title: Reading Text
      code: https://webassembly.studio/?embed&f=ubmxmavgf2
      content_markdown: |
        Let's explore the opposite idea. Imagine we want to give some text to a WebAssembly program.

        We must:
        1. Determine the length in bytes of the text we want to pass in.
        1. Allocate some space in our memory of that byte length.
        2. Copy bytes into our program's memory at the start of the space we allocated.
        3. Let the WebAssembly program know we have put some data in it's memory at a specific index and lenth in bytes.

        ```javascript
        // Turn "Ferris" into bytes
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Allocate enough space for the text
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Put the text in WebAssembly program's memory
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Run the program
        module.instance.exports.main(start,len);
        ```

  - beta: true
    en:
      title: Discovering Representations
      content_markdown: |
        You might find it annoying to pass around the length along with the start index of text.

        Consider this an opportunity to reflect upon useful conventions of the past like *C strings*
        that declare the end of text is a 0 value character `\0`.

        Don't want to pass around a byte packed data structure? Consider passing around json.

        You are in control of your representations in memory and what they mean and if they
        are appropriate for your use cases!
  - beta: true
    en:
      title: Chapter 2 Conclusion
      content_markdown: |
        Crossing the boundry between host and WebAssembly program is cumbersome, but with it can come great performance. 
        It's important to remind ourselves that WebAssembly is a low -level executable byte code with concerns about memory
        structures that are much fine-grained than JavaScript. Check out your programming language's
        library support for tools that help make this an easier task! For Rust, [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) is a popular option.

        In our next chapter we will talk about a technique for dynamically calling JavaScript functions and garbage collection!
  - chapter: 3
    en:
      title: The End
      content_markdown: |
        That's all for now. Stay tuned for new content. I hope you enjoy the journey ahead!
    en_c:
      clone: en
    ie:
      title: Fine
      content_markdown: |
        To es omnicos por nu. Plu tard va venir nov contenete. Yo espera que tu va juir li viage a sequer!
    pt-br:
      title: Fim
      content_markdown: |
        Isso é tudo por enquanto. Fique ligado para novos conteúdos. Espero que
        se divirta nesta jornada!
    es:
      title: Fin
      content_markdown: |
        Esto es todo por ahora, pero aún quedan más capítulos, así que ¡muy atento! Esperamos que disfrutes del viaje.
